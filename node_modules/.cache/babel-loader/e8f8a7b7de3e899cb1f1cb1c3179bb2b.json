{"ast":null,"code":"import React from 'react';\nimport { observable, autorun, action, decorate, toJS } from \"mobx\";\nimport API from './API';\nimport u from './Utilities';\nimport ImageTest from './static/img/user-placeholder.png';\nimport Utilities from './Utilities';\nexport class Store {\n  // defining store sections\n  // functions for different parts of store\n  // sets cache portion of store (kinda like React setState)\n  setCache(sector, data) {\n    this.cache = { ...this.cache,\n      [sector]: { ...this.cache[sector],\n        ...data\n      }\n    };\n  } // clears user info\n\n\n  wipeUser() {\n    this.user = { ...this.user,\n      username: \"\",\n      email: \"\",\n      taxon: \"\",\n      createdOn: \"\",\n      isLoggedIn: false,\n      images: {\n        profile: \"\"\n      }\n    };\n    this.channels = [];\n  }\n\n  raiseError() {\n    this.system.isError = true;\n    this.system.errorMessage = \"testing\";\n  }\n\n  initializeAnonToken() {\n    this.wipeUser();\n    u.deleteCookie(\"f30_tok\");\n    API.getAnonymousToken().then(success => {}, error => {\n      console.log(\"Error\");\n      console.log(error);\n    });\n  }\n\n  checkChannelOwnership(taxon) {\n    let isOwnedChannel = this.channels.filter(channel => {\n      return channel.taxon == taxon;\n    });\n    return isOwnedChannel.length > 0 ? true : false;\n  }\n\n  load() {\n    let jwtObject = API.getJWTObject();\n    let unlockEmitter = false;\n\n    if (jwtObject == null || jwtObject == undefined) {\n      this.initializeAnonToken();\n    }\n\n    API.getUser({}).then(success => {\n      if (success.status == 200 && success.data.length > 0) {\n        let u = success.data[0];\n        unlockEmitter = true;\n        this.user = {\n          username: u.username,\n          email: u.email_address,\n          taxon: u.taxon,\n          isLoggedIn: jwtObject.anonymous ? false : true,\n          createdOn: u.created_on,\n          isLoading: false,\n          rank: u.rank,\n          images: {\n            profile: u.profile_picture_url\n          }\n        };\n        this.channels = u.channels;\n      } else {\n        if (this.system.loadRetryCount < this.system.loadRetryLimit) {\n          this.system.loadRetryCount++;\n          this.initializeAnonToken();\n          this.load();\n          return;\n        }\n\n        this.user = { ...this.user,\n          isLoading: false\n        };\n        console.log(`Exceeded maximum retry count (out of ${this.system.loadRetryLimit}); halting store intialization.`);\n      }\n    }, error => {\n      console.log(\"Error\");\n      console.log(error);\n      u.deleteCookie(\"f30_tok\");\n\n      if (this.system.loadRetryCount < this.system.loadRetryLimit) {\n        this.system.loadRetryCount++;\n        this.initializeAnonToken();\n        this.load();\n        return;\n      }\n\n      this.user = { ...this.user,\n        isLoading: false\n      };\n      console.log(`Exceeded maximum retry count (out of ${this.system.loadRetryLimit}); halting store intialization.`);\n    }).finally(() => {\n      if (unlockEmitter) {\n        API.emitter.emit(\"storesynced\");\n      }\n    });\n  }\n\n  constructor() {\n    this.system = {\n      isError: false,\n      errorMessage: \"\",\n      loadRetryCount: 0,\n      loadRetryLimit: 3\n    };\n    this.user = {\n      username: \"\",\n      email: \"\",\n      taxon: \"\",\n      createdOn: \"\",\n      isLoggedIn: false,\n      isLoading: true,\n      rank: \"\",\n      images: {\n        profile: \"\"\n      }\n    };\n    this.channels = [];\n    this.cache = {\n      studio: {\n        isLoading: true,\n        isUpdating: false,\n        channel: {\n          title: \"\",\n          subscriberCount: 0,\n          taxon: \"\",\n          images: {\n            icon: \"\"\n          }\n        },\n        analytics: {\n          isLoading: true,\n          membershipCount: 0,\n          tipCount: 0,\n          statistics: {\n            totalViewCount: 0,\n            subscriberCount: 0,\n            membershipCount: 0\n          }\n        },\n        videos: []\n      },\n      vcc: {\n        isInitialLoading: true,\n        isLoading: true,\n        isError: false,\n        videos: [],\n        perPage: 30,\n        currentPage: 1\n      }\n    };\n    this.actions = {\n      studio: {\n        // studio - load channel\n        loadChannel: taxon => {\n          this.cache.studio.isUpdating = true;\n          API.getChannel({\n            taxon: taxon\n          }).then(success => {\n            if (success.status == 200) {\n              let c = success.data[0];\n              this.setCache(\"studio\", {\n                channel: {\n                  title: c.title,\n                  statistics: c.statistics,\n                  taxon: c.taxon,\n                  slug: c.slug,\n                  images: {\n                    icon: c.channel_picture_url\n                  }\n                }\n              });\n            }\n          }, error => {}).finally(() => {\n            API.getVideos({\n              page: 1,\n              perPage: 1000,\n              channelTaxon: taxon\n            }).then(success => {\n              if (success.status == 200) {\n                this.setCache(\"studio\", {\n                  isLoading: false,\n                  isUpdating: false,\n                  videos: success.data\n                });\n              }\n            }).finally(() => {\n              if (this.cache.studio.videos.length > 0) {\n                console.log(this.cache.studio.videos.length);\n\n                for (var v of this.cache.studio.videos) {\n                  v.processed = true; // let m = v.media;\n                  // v.processed = (m.transforms[240] !== null || m.transforms[480] !== null || m.transforms[720] !== null || m.transforms[1080] !== null);\n                }\n              }\n            });\n          });\n          API.getChannelAnalytics({\n            channelTaxon: taxon\n          }).then(success => {\n            if (success.status == 200) {\n              let a = success.data;\n              this.setCache(\"studio\", {\n                analytics: {\n                  isLoading: false,\n                  membershipCount: a.membership_count,\n                  tipCount: a.tip_count,\n                  statistics: {\n                    totalViewCount: a.stats ? a.stats.total_view_count : 0,\n                    subscriberCount: a.stats ? a.stats.subscriber_count : 0,\n                    membershipCount: a.stats ? a.stats.membership_count : 0\n                  }\n                }\n              });\n            }\n          });\n        },\n        // studio - check video process\n        updateVideoProcess: (taxon, onProgress = null) => {\n          let emitOnProgress = message => {\n            if (onProgress) {\n              onProgress(message);\n            }\n          };\n\n          return new Promise((resolve, reject) => {\n            emitOnProgress(\"Checking EPIC.IO manifest for \" + taxon + \"...\");\n            API.getVideoManifest(taxon).then(success => {\n              // shortnaming manifest\n              try {\n                let man = success.data; // checking if manifest has successfully completed\n\n                if (man.meta.status === \"SUCCESS\") {\n                  emitOnProgress(\"Manifest successful for \" + taxon + \"...\");\n                  emitOnProgress(\"Generating transforms for video object...\"); // generates a valid body for update video with transforms setup\n\n                  let body = Utilities.generateUpdateVideoBodyFromManifest(taxon, man); // updating video object\n\n                  API.updateVideo(body).then(success => {\n                    // emitOnProgress(\"Video media has been copied successfully.\");\n                    resolve(\"Video media has been copied successfully.\");\n                  });\n                } else {\n                  console.error(\"Video processing failed from EPIC.IO for \" + taxon + \".\");\n                  reject(\"Video processing failed from EPIC.IO for \" + taxon + \".\");\n                }\n              } catch (error) {\n                reject(\"Exception occured in manifest function stack\");\n              }\n            }, error => {\n              console.log(\"Error reached on video update\");\n              reject(\"Error reached on video manifest request.\");\n            });\n          });\n        }\n      },\n      vcc: {\n        load: parameters => {\n          this.setCache(\"vcc\", {\n            isLoading: true\n          });\n\n          if (parameters.latest) {\n            API.getVideos({\n              perPage: this.cache.vcc.perPage,\n              page: this.cache.vcc.currentPage,\n              latest: true\n            }).then(success => {\n              if (success.status == 200) {\n                this.setCache(\"vcc\", {\n                  isLoading: false,\n                  isInitialLoading: false,\n                  isError: false,\n                  videos: this.cache.vcc.videos.concat(success.data)\n                });\n              } else {\n                this.setCache(\"vcc\", {\n                  isLoading: false,\n                  isInitialLoading: false,\n                  isError: true\n                });\n              }\n            }, error => {\n              this.setCache(\"vcc\", {\n                isLoading: false,\n                isInitialLoading: false,\n                isError: true\n              });\n            });\n          } else if (parameters.hot) {\n            API.getVideos({\n              perPage: this.cache.vcc.perPage,\n              page: this.cache.vcc.currentPage,\n              hot: true\n            }).then(success => {\n              if (success.status == 200) {\n                this.setCache(\"vcc\", {\n                  isLoading: false,\n                  isInitialLoading: false,\n                  isError: false,\n                  videos: this.cache.vcc.videos.concat(success.data)\n                });\n              } else {\n                this.setCache(\"vcc\", {\n                  isLoading: false,\n                  isInitialLoading: false,\n                  isError: true\n                });\n              }\n            }, error => {\n              this.setCache(\"vcc\", {\n                isLoading: false,\n                isInitialLoading: false,\n                isError: true\n              });\n            });\n          } else if (parameters.trending) {\n            API.getVideos({\n              perPage: this.cache.vcc.perPage,\n              page: this.cache.vcc.currentPage,\n              trending: true\n            }).then(success => {\n              if (success.status == 200) {\n                this.setCache(\"vcc\", {\n                  isLoading: false,\n                  isInitialLoading: false,\n                  isError: false,\n                  videos: this.cache.vcc.videos.concat(success.data)\n                });\n              } else {\n                this.setCache(\"vcc\", {\n                  isLoading: false,\n                  isInitialLoading: false,\n                  isError: true\n                });\n              }\n            }, error => {\n              this.setCache(\"vcc\", {\n                isLoading: false,\n                isInitialLoading: false,\n                isError: true\n              });\n            });\n          } else {\n            API.getVideos({\n              perPage: this.cache.vcc.perPage,\n              page: this.cache.vcc.currentPage\n            }).then(success => {\n              if (success.status == 200) {\n                this.setCache(\"vcc\", {\n                  isLoading: false,\n                  isInitialLoading: false,\n                  isError: false,\n                  videos: this.cache.vcc.videos.concat(success.data)\n                });\n              } else {\n                this.setCache(\"vcc\", {\n                  isLoading: false,\n                  isInitialLoading: false,\n                  isError: true\n                });\n              }\n            }, error => {\n              this.setCache(\"vcc\", {\n                isLoading: false,\n                isInitialLoading: false,\n                isError: true\n              });\n            });\n          }\n        },\n        getNextPage: parameters => {\n          this.setCache(\"vcc\", {\n            currentPage: this.cache.vcc.currentPage + 1\n          });\n          this.actions.vcc.load(parameters);\n        },\n        clearVideos: () => {\n          this.setCache(\"vcc\", {\n            videos: []\n          });\n        },\n        reinit: () => {\n          this.actions.vcc.clearVideos();\n          this.setCache(\"vcc\", {\n            isInitialLoading: true,\n            currentPage: 1\n          });\n        }\n      }\n    };\n    console.log(\"store init called\");\n    this.load();\n  }\n\n}\ndecorate(Store, {\n  user: observable,\n  channels: observable,\n  cache: observable\n});\nexport let store = new Store();","map":{"version":3,"sources":["/Users/hfish/Development/school/software_engineering/crafting_tracker/src/Store.js"],"names":["React","observable","autorun","action","decorate","toJS","API","u","ImageTest","Utilities","Store","setCache","sector","data","cache","wipeUser","user","username","email","taxon","createdOn","isLoggedIn","images","profile","channels","raiseError","system","isError","errorMessage","initializeAnonToken","deleteCookie","getAnonymousToken","then","success","error","console","log","checkChannelOwnership","isOwnedChannel","filter","channel","length","load","jwtObject","getJWTObject","unlockEmitter","undefined","getUser","status","email_address","anonymous","created_on","isLoading","rank","profile_picture_url","loadRetryCount","loadRetryLimit","finally","emitter","emit","constructor","studio","isUpdating","title","subscriberCount","icon","analytics","membershipCount","tipCount","statistics","totalViewCount","videos","vcc","isInitialLoading","perPage","currentPage","actions","loadChannel","getChannel","c","slug","channel_picture_url","getVideos","page","channelTaxon","v","processed","getChannelAnalytics","a","membership_count","tip_count","stats","total_view_count","subscriber_count","updateVideoProcess","onProgress","emitOnProgress","message","Promise","resolve","reject","getVideoManifest","man","meta","body","generateUpdateVideoBodyFromManifest","updateVideo","parameters","latest","concat","hot","trending","getNextPage","clearVideos","reinit","store"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { observable, autorun, action, decorate, toJS } from \"mobx\";\n\nimport API from './API';\nimport u from './Utilities';\n\nimport ImageTest from './static/img/user-placeholder.png';\nimport Utilities from './Utilities';\n\nexport class Store {\n    // defining store sections\n    system = {\n        isError: false,\n        errorMessage: \"\",\n        loadRetryCount: 0,\n        loadRetryLimit: 3\n    }\n\n    user = {\n        username: \"\",\n        email: \"\",\n        taxon: \"\",\n        createdOn: \"\",\n        isLoggedIn: false,\n        isLoading: true,\n        rank: \"\",\n        images: {\n            profile: \"\"\n        }\n    };\n\n    channels = [];\n\n    cache = {\n        studio: {\n            isLoading: true,\n            isUpdating: false,\n            channel: {\n                title: \"\",\n                subscriberCount: 0,\n                taxon: \"\",\n                images: {\n                    icon: \"\"\n                }\n            },\n            analytics: {\n                isLoading: true,\n                membershipCount: 0,\n                tipCount: 0,\n                statistics: {\n                    totalViewCount: 0,\n                    subscriberCount: 0,\n                    membershipCount: 0\n                }\n            },\n            videos: []\n        },\n        vcc: {\n            isInitialLoading: true,\n            isLoading: true,\n            isError: false,\n            videos: [],\n            perPage: 30,\n            currentPage: 1\n        }\n    }\n\n    // functions for different parts of store\n    actions = {\n        studio: {\n            // studio - load channel\n            loadChannel: (taxon) => {\n                this.cache.studio.isUpdating = true;\n                API.getChannel({taxon: taxon}).then(\n                    (success) => {\n                        if(success.status == 200) {\n                            let c = success.data[0];\n                            this.setCache(\"studio\", {\n                                channel: {\n                                    title: c.title,\n                                    statistics: c.statistics,\n                                    taxon: c.taxon,\n                                    slug: c.slug,\n                                    images: {\n                                        icon: c.channel_picture_url\n                                    }\n                                }\n                            });\n                        }\n                    },\n                    (error) => {\n\n                    }\n                ).finally(\n                    () => {\n                        API.getVideos({page: 1, perPage: 1000, channelTaxon: taxon}).then(\n                            (success) => {\n                                if(success.status == 200) {\n                                    this.setCache(\"studio\", {\n                                        isLoading: false,\n                                        isUpdating: false,\n                                        videos: success.data\n                                    });\n                                }\n                            }\n                        ).finally(\n                            () => {\n                                if(this.cache.studio.videos.length > 0) {\n                                    console.log(this.cache.studio.videos.length);\n                                    for(var v of this.cache.studio.videos) {\n                                        v.processed = true;\n                                        // let m = v.media;\n                                        // v.processed = (m.transforms[240] !== null || m.transforms[480] !== null || m.transforms[720] !== null || m.transforms[1080] !== null);\n                                    }\n                                }\n                            }\n                        );\n                    }\n                );\n\n                API.getChannelAnalytics({channelTaxon: taxon}).then(\n                    (success) => {\n                        if(success.status == 200) {\n                            let a = success.data;\n                            this.setCache(\"studio\", {\n                                analytics: {\n                                    isLoading: false,\n                                    membershipCount: a.membership_count,\n                                    tipCount: a.tip_count,\n                                    statistics: {\n                                        totalViewCount: a.stats ? a.stats.total_view_count : 0,\n                                        subscriberCount: a.stats ? a.stats.subscriber_count : 0,\n                                        membershipCount: a.stats ? a.stats.membership_count : 0\n                                    }\n                                }\n                            });\n                        }\n                    }\n                );\n            },\n            // studio - check video process\n            updateVideoProcess: (taxon, onProgress = null) => {\n                let emitOnProgress = (message) => {\n                    if(onProgress) {\n                        onProgress(message);\n                    }\n                }\n                return new Promise((resolve, reject) => {\n                    emitOnProgress(\"Checking EPIC.IO manifest for \" + taxon + \"...\");\n                    API.getVideoManifest(taxon).then(\n                        (success) => {\n                            // shortnaming manifest\n                            try {\n                                let man = success.data;\n\n                                // checking if manifest has successfully completed\n                                if(man.meta.status === \"SUCCESS\") {\n                                    emitOnProgress(\"Manifest successful for \" + taxon + \"...\");\n\n                                    emitOnProgress(\"Generating transforms for video object...\");\n                                    // generates a valid body for update video with transforms setup\n                                    let body = Utilities.generateUpdateVideoBodyFromManifest(taxon, man);\n\n                                    // updating video object\n                                    API.updateVideo(body).then(\n                                        (success) => {\n                                            // emitOnProgress(\"Video media has been copied successfully.\");\n                                            resolve(\"Video media has been copied successfully.\");\n                                        }\n                                    );\n                                } else {\n                                    console.error(\"Video processing failed from EPIC.IO for \" + taxon + \".\");\n                                    reject(\"Video processing failed from EPIC.IO for \" + taxon + \".\");\n                                }\n                            } catch(error) {\n                                reject(\"Exception occured in manifest function stack\");\n                            }\n                        },\n                        (error) => {\n                            console.log(\"Error reached on video update\");\n                            reject(\"Error reached on video manifest request.\");\n                        }\n                    )\n                });\n            }\n        },\n        vcc: {\n            load: (parameters) => {\n                this.setCache(\"vcc\", {isLoading: true});\n                if(parameters.latest) {\n                    API.getVideos({ perPage: this.cache.vcc.perPage, page: this.cache.vcc.currentPage, latest: true }).then(\n                        (success) => {\n                            if(success.status == 200) {\n                                this.setCache(\"vcc\", {\n                                    isLoading: false,\n                                    isInitialLoading: false,\n                                    isError: false,\n                                    videos: this.cache.vcc.videos.concat(success.data)\n                                })\n                            } else {\n                                this.setCache(\"vcc\", {\n                                    isLoading: false,\n                                    isInitialLoading: false,\n                                    isError: true\n                                });\n                            }\n                        },\n                        (error) => {\n                            this.setCache(\"vcc\", {\n                                isLoading: false,\n                                isInitialLoading: false,\n                                isError: true\n                            });\n                        }\n                    );\n                } else if(parameters.hot) {\n                    API.getVideos({ perPage: this.cache.vcc.perPage, page: this.cache.vcc.currentPage, hot: true }).then(\n                        (success) => {\n                            if(success.status == 200) {\n                                this.setCache(\"vcc\", {\n                                    isLoading: false,\n                                    isInitialLoading: false,\n                                    isError: false,\n                                    videos: this.cache.vcc.videos.concat(success.data)\n                                });\n                            } else {\n                                this.setCache(\"vcc\", {\n                                    isLoading: false,\n                                    isInitialLoading: false,\n                                    isError: true\n                                });\n                            }\n                        },\n                        (error) => {\n                            this.setCache(\"vcc\", {\n                                isLoading: false,\n                                isInitialLoading: false,\n                                isError: true\n                            });\n                        }\n                    );\n                } else if(parameters.trending) {\n                    API.getVideos({ perPage: this.cache.vcc.perPage, page: this.cache.vcc.currentPage, trending: true }).then(\n                        (success) => {\n                            if(success.status == 200) {\n                                this.setCache(\"vcc\", {\n                                    isLoading: false,\n                                    isInitialLoading: false,\n                                    isError: false,\n                                    videos: this.cache.vcc.videos.concat(success.data)\n                                });\n                            } else {\n                                this.setCache(\"vcc\", {\n                                    isLoading: false,\n                                    isInitialLoading: false,\n                                    isError: true\n                                });\n                            }\n                        },\n                        (error) => {\n                            this.setCache(\"vcc\", {\n                                isLoading: false,\n                                isInitialLoading: false,\n                                isError: true\n                            });\n                        }\n                    );\n                } else {\n                    API.getVideos({ perPage: this.cache.vcc.perPage, page: this.cache.vcc.currentPage }).then(\n                        (success) => {\n                            if(success.status == 200) {\n                                this.setCache(\"vcc\", {\n                                    isLoading: false,\n                                    isInitialLoading: false,\n                                    isError: false,\n                                    videos: this.cache.vcc.videos.concat(success.data)\n                                });\n                            } else {\n                                this.setCache(\"vcc\", {\n                                    isLoading: false,\n                                    isInitialLoading: false,\n                                    isError: true\n                                });\n                            }\n                        },\n                        (error) => {\n                            this.setCache(\"vcc\", {\n                                isLoading: false,\n                                isInitialLoading: false,\n                                isError: true\n                            });\n                        }\n                    );\n                }\n            },\n            getNextPage: (parameters) => {\n                this.setCache(\"vcc\", {\n                    currentPage: this.cache.vcc.currentPage + 1\n                });\n                this.actions.vcc.load(parameters);\n            },\n            clearVideos: () => {\n                this.setCache(\"vcc\", {\n                    videos: []\n                })\n            },\n            reinit: () => {\n                this.actions.vcc.clearVideos();\n                this.setCache(\"vcc\", {\n                    isInitialLoading: true,\n                    currentPage: 1\n                })\n            }\n        }\n    }\n\n    // sets cache portion of store (kinda like React setState)\n    setCache(sector, data) {\n        this.cache = {\n            ...this.cache,\n            [sector]: {\n                ...this.cache[sector],\n                ...data\n            }\n        }\n    }\n\n    // clears user info\n    wipeUser() {\n        this.user = {\n            ...this.user,\n            username: \"\",\n            email: \"\",\n            taxon: \"\",\n            createdOn: \"\",\n            isLoggedIn: false,\n            images: {\n                profile: \"\"\n            }\n        }\n        this.channels = []\n    }\n\n    raiseError() {\n        this.system.isError = true;\n        this.system.errorMessage = \"testing\";\n    }\n\n    initializeAnonToken() {\n        this.wipeUser();\n        u.deleteCookie(\"f30_tok\");\n        API.getAnonymousToken().then(\n            (success) => {\n            },\n            (error) => {\n                console.log(\"Error\");\n                console.log(error);\n            }\n        );\n    }\n\n    checkChannelOwnership(taxon) {\n        let isOwnedChannel = this.channels.filter((channel) => {\n            return channel.taxon == taxon\n        })\n\n        return (isOwnedChannel.length > 0 ? true : false);\n    }\n\n    load() {\n        let jwtObject = API.getJWTObject();\n        let unlockEmitter = false;\n\n        if(jwtObject == null || jwtObject == undefined) {\n            this.initializeAnonToken();\n        }\n\n        API.getUser({}).then(\n            (success) => {\n                if (success.status == 200 && success.data.length > 0) {\n                    let u = success.data[0];\n                    unlockEmitter = true;\n                    this.user = {\n                        username: u.username,\n                        email: u.email_address,\n                        taxon: u.taxon,\n                        isLoggedIn: jwtObject.anonymous ? false : true,\n                        createdOn: u.created_on,\n                        isLoading: false,\n                        rank: u.rank,\n                        images: {\n                            profile: u.profile_picture_url\n                        }\n                    }\n                    this.channels = u.channels;\n                } else {\n                    if(this.system.loadRetryCount < this.system.loadRetryLimit) {\n                        this.system.loadRetryCount++;\n                        this.initializeAnonToken();\n                        this.load();\n                        return;\n                    }\n                    this.user = {\n                        ...this.user,\n                        isLoading: false\n                    }\n                    console.log(`Exceeded maximum retry count (out of ${this.system.loadRetryLimit}); halting store intialization.`)\n                }\n            },\n            (error) => {\n                console.log(\"Error\");\n                console.log(error);\n                u.deleteCookie(\"f30_tok\");\n                if(this.system.loadRetryCount < this.system.loadRetryLimit) {\n                    this.system.loadRetryCount++;\n                    this.initializeAnonToken();\n                    this.load();\n                    return;\n                }\n                this.user = {\n                    ...this.user,\n                    isLoading: false\n                }\n                console.log(`Exceeded maximum retry count (out of ${this.system.loadRetryLimit}); halting store intialization.`)\n            }\n        ).finally(() => {\n            if(unlockEmitter) {\n                API.emitter.emit(\"storesynced\");\n            }\n        });\n    }\n\n    constructor() {\n        console.log(\"store init called\");\n        this.load();\n    }\n}\n\ndecorate(Store, {\n    user: observable,\n    channels: observable,\n    cache: observable\n});\n\nexport let store = new Store();\n"]},"metadata":{},"sourceType":"module"}